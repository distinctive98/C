#include <stdio.h>

#define ORD_MAX 7

EXEC SQL INCLUDE sqlca;
EXEC SQL INCLUDE oraca;
EXEC ORACLE OPTION (ORACA=YES);

char	sqlstmt[512];

int tr2(_cust_id)
int _cust_id;
{

	/* orders 테이블에 대한 구조체(무조건 select 순서와 같아야 함) */
	struct order_t {
		int		order_id;
		int 	o_cust_id;
		char	order_dt[8+1];
		char	order_channel_type[1+1];
		char	order_status[1+1];
		int		order_rct_emp_id;
	};

	/* 구조체 배열 선언  */
	struct order_t ord[ORD_MAX];

	int	i=0;
	int	j=0;

	/* cust_id에 해당하는 행 ORDERS 테이블에서 추출 */
	EXEC SQL DECLARE C02 CURSOR FOR
	SELECT	ORDER_ID,
		CUST_ID,
		TO_CHAR(ORDER_DT, 'YYYYMMDD'),
		ORDER_CHANNEL_TYPE,
		ORDER_STATUS,
		NVL(ORDER_RCT_EMP_ID, -1)
	FROM	ORDERS
	WHERE	CUST_ID= :_cust_id;
	
	/* 커서 오픈 */
	EXEC SQL OPEN C02;

	/* 구조체 크기에 맞게 FETCH 진행  */
	while(1)
	{
		/* 구조체 메모리 초기화(FETCH 전에 필수로 해야 함) */
		memset(ord, 0x00, sizeof(ord));

		/* 구조체에 FETCH  */
		EXEC SQL FETCH C02
			INTO 	:ord;

		/* sqlca.sqlerrd[2]에는 FETCH건수가 저장되어 있음  */
		/* sqlca.sqlerrd[2]는 중첩문에 의해 구조체 크기의 배수로 증가됨 */
		for(i=0; i<sqlca.sqlerrd[2]-(ORD_MAX*j); i++)
		{	
			printf("%d %d %s %s %s %d\n",
				ord[i].order_id, ord[i].o_cust_id, ord[i].order_dt, ord[i].order_channel_type, 
				ord[i].order_status, ord[i].order_rct_emp_id);

		}

		if(sqlca.sqlcode == 1403)
			break;

		j++;
	}

	printf("%d건이 검색되었습니다.\n", sqlca.sqlerrd[2]);

	EXEC SQL CLOSE C02;
	return (0);
}

